<?php
/*
 * 4/11/2020
 * 有关MVC和三层架构的理解
 * 在最开始(无互联网应用)时,MVC确实只是一种设计模式,是根据观察者模式演变而来
 * 例如一个本地页面,M隐藏在JS中的数据实体(只是简单的数据类并实现Observable接口)
 * V是本地页面各种元素集合，例如一个窗口显示M的值，窗口实现可监听Observable
 * C是一个Observer类或一段addEventListener的回调函数，同时存在多个
 * 例如 C1监听button点击事件并实现M值+1. 然后M的值改变notify控制器C2,调用C2的update(Model)
 * C2用更新后的Model更新V
 * 需要一个总控制器类来实现多个控制器(监视器)的绑定，实际上就是对Observable添加Observer
 *
 *
 * 再后来,出现互联网,使得V与MC中间加了一层网络
 * 需要添加一个路由分发控制器C3或web.xml(Tomcat)
 * C1演变成路由控制器,接受前端button点击请求后,调用Model的业务逻辑并修改Model,
 * 然后forward请求给C2,让C2返回一个新的V给前端
 * 此时的M包含了业务逻辑层和数据访问层(JavaBean),C只是调用M的业务逻辑,所以不应该把复杂的业务逻辑代码放在C中
 * 所以此时MVC的框架(注意此时MVC演变为框架)图应为
 *           1     -------------------      2    -----------               ----------     5
 * Browser----->  | DispatchController|  -----> | Controller|             |   View   |-------->Browser
                   -------------------           -----------               ----------
                                                        3 \\            // 4
                                                             ----------
                                                            |   Model  |
                                                             ----------
 * M因为囊括了业务逻辑层和数据访问层,所以沉在下面(便于记忆)
 * 对于web应用来说,laravel整体上是MVC架构,V就是View的blade
 * 对于前后端分离的laravel返回json格式数据来说,从整体结构上来说,laravel只是M层, VC层由前端掌握(至于前端请求后端的路由,就不算Controller层了,
 * 或者不从整体结构上说,laravel仍然是子MVC结构,后端路由仍是C层,此时的V是json数据格式)
 *
 * 再后来,将M层拆分,拆分成业务逻辑层和数据访问层,M退化成POJO(朴素java对象)
 * 而C和V不变
 * 所以三层架构中的表示层是MVC架构中的VC+退化后的M
 * 业务逻辑层是MVC中M的拆分
 * 数据访问层是MVC中M的拆分
 * 所以springMVC是三层架构中web表现层架构，用于开发web应用,在其Handler中调用业务逻辑层代码并返回数据实体模型,
 * springMVC是spring三层架构的服务器的一部分,是架构中的表现层
 * 而对于业务层和数据访问层,与表示层无关,即无论是web应用还是app,这两层都不变,变的只是表示层
 * https://juejin.im/post/6869253275095564302
 *
*/
